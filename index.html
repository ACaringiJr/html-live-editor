<!DOCTYPE html>
<html>
<meta charset="UTF-8">
<title>HTML Playground | Live Code Editor</title>
<link rel="icon" type="image/x-icon" href="https://img.icons8.com/?size=256&id=20909&format=png">

<style>
  :root {
    --editor-bg-primary: #ffffff;
    --editor-bg-secondary: #f0f0f0;
    --editor-text-primary: #000000;
    --editor-border-color: #cccccc;
    --highlight-bg: #d3d3d3;
    --match-bracket-outline: #44475a;
    --match-bracket-color: #ff0000;
  }

  .save-status {
    transition: opacity 0.4s ease;
  }

  .editor-wrapper.dark-mode {
    --editor-bg-primary: #272822;
    --editor-bg-secondary: #3a3d4b;
    --editor-text-primary: #f8f8f2;
    --editor-border-color: #6272a4;
    --highlight-bg: #6272a4;
    --match-bracket-outline: #ffffff;
    --match-bracket-color: #ff5555;
  }

  html, body {
    height: 100%;
    margin: 0;
    padding: 0;
    overflow: hidden;
    font-family: Arial, sans-serif;
  }

  body {
    padding-top: env(safe-area-inset-top);
    padding-bottom: env(safe-area-inset-bottom);
  }

  .container {
    display: grid;
    grid-template-columns: 1fr 5px 1fr;
    grid-template-rows: 100%;
    min-height: 100dvh;
  }

  .editor-wrapper {
    display: flex;
    flex-direction: column;
    overflow: hidden;
    background-color: var(--editor-bg-primary);
    position: relative;
  }

  #editor {
    flex-grow: 1;
    width: 100%;
    background-color: var(--editor-bg-primary);
    color: var(--editor-text-primary);
  }

  .ace_editor {
    border: 1px solid var(--editor-border-color);
  }

  .resizer {
    background: #ccc;
    cursor: col-resize;
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 10;
    position: relative;
  }

  .resizer::after {
    content: '⋮';
    color: #666;
    font-size: 20px;
  }

  .resizer:hover {
    background: #999;
  }

  #rightPanel {
    display: grid;
    grid-template-rows: 1fr;
    height: 100%;
  }

  #preview {
    overflow: auto;
    background: var(--editor-bg-secondary);
    position: relative;
  }

  .preview-loading {
    position: absolute;
    top: 10px;
    right: 10px;
    background: rgba(0, 0, 0, 0.7);
    color: #fff;
    padding: 5px 10px;
    border-radius: 3px;
    display: none;
  }

  #consoleSection {
    background: #1a1a1a;
    color: #ffffff;
    font-family: monospace;
    padding: 10px;
    overflow-y: auto;
    display: none;
  }

  .console-log {
    margin: 2px 0;
    word-wrap: break-word;
  }
  .console-log.log { color: #ffffff; }
  .console-log.error { color: #ff6b6b; }
  .console-log.warn { color: #feca57; }

  .vertical-resizer {
    background: #ccc;
    cursor: row-resize;
    display: none;
    align-items: center;
    justify-content: center;
    z-index: 10;
  }
  .vertical-resizer::after {
    content: '─';
    color: #666;
    font-size: 20px;
  }
  .vertical-resizer:hover {
    background: #999;
  }

  .buttons {
    padding: 10px;
    background: var(--editor-bg-secondary);
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding-bottom: calc(10px + env(safe-area-inset-bottom));
  }

  .buttons button {
    margin: 0 5px;
    cursor: pointer;
    background: #e0e0e0;
    border: 1px solid var(--editor-border-color);
    padding: 5px 10px;
    border-radius: 3px;
    transition: background 0.2s;
  }

  .buttons button:hover {
    background: #d0d0d0;
  }

  .editor-wrapper.dark-mode .buttons {
    background: var(--editor-bg-secondary);
  }
  .editor-wrapper.dark-mode .buttons button {
    background: #44475a;
    color: #f8f8f2;
    border: 1px solid var(--editor-border-color);
  }
  .editor-wrapper.dark-mode .buttons button:hover {
    background: #55576a;
  }

  .mode-toggle {
    display: flex;
    align-items: center;
    padding-bottom: calc(10px + env(safe-area-inset-bottom));
  }
  .mode-toggle label {
    margin-right: 10px;
    margin-left: 20px;
  }

  .save-status {
    color: #4CAF50;
    font-size: 12px;
    margin-left: 10px;
  }

  .ace_highlight-occurrence {
    background-color: var(--highlight-bg);
    position: absolute;
    z-index: 20;
  }

  #findReplaceModal {
    position: absolute;
    top: 20px;
    right: 20px;
    width: 320px;
    background-color: var(--editor-bg-primary);
    border: 1px solid var(--editor-border-color);
    border-radius: 8px;
    z-index: 200;
    display: none;
    box-shadow: 0 6px 16px rgba(0, 0, 0, 0.4);
    color: var(--editor-text-primary);
    padding: 55px 15px 20px 15px; 
  }

  .draggable-handle {
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    background: var(--editor-bg-secondary);
    text-align: center;
    padding: 8px 0;
    font-size: 13px;
    font-weight: 600;
    border-radius: 8px 8px 0 0;
    border-bottom: 1px solid var(--editor-border-color);
    cursor: move;
    letter-spacing: 0.3px;
  }

  #findReplaceModal .close-btn {
    position: absolute;
    top: 5px;
    right: 10px;
    background: transparent;
    border: none;
    color: var(--editor-text-primary);
    font-size: 18px;
    cursor: pointer;
    transition: transform 0.15s ease, color 0.15s ease;
  }
  #findReplaceModal .close-btn:hover {
    color: #ff5555;
    transform: scale(1.2);
  }

  #findReplaceModal input[type="text"] {
    width: 100%;
    margin: 8px 0;
    padding: 7px 8px;
    border-radius: 4px;
    font-size: 13px;
    background: var(--editor-bg-secondary);
    color: var(--editor-text-primary);
    border: 1px solid var(--editor-border-color);
    outline: none;
    transition: border 0.2s, box-shadow 0.2s;
  }
  #findReplaceModal input[type="text"]:focus {
    border-color: #50fa7b;
    box-shadow: 0 0 0 2px rgba(80, 250, 123, 0.25);
  }

  #findReplaceModal div label {
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 12px;
    color: var(--editor-text-primary);
    margin-top: 8px;
  }
  #findReplaceModal input[type="checkbox"] {
    margin-right: 6px;
    accent-color: #50fa7b;
  }

  #findReplaceModal .modal-buttons {
    display: flex;
    justify-content: space-between;
    margin-top: 14px;
  }
  #findReplaceModal .modal-buttons button {
    flex: 1;
    margin: 0 3px;
    padding: 6px 0;
    font-size: 13px;
    background: #44475a;
    color: #f8f8f2;
    border: 1px solid var(--editor-border-color);
    border-radius: 4px;
    cursor: pointer;
    transition: background 0.2s, transform 0.1s;
  }
  #findReplaceModal .modal-buttons button:hover {
    background: #6272a4;
  }
  #findReplaceModal .modal-buttons button:active {
    transform: scale(0.96);
  }

  .mode-toggle {
    display: flex;
    align-items: center;         
    gap: 10px;                   
  }

  .mode-toggle label {
    color: var(--editor-text-primary);  
    font-size: 13px;
    display: flex;
    align-items: center;         
    margin: 0;                   
  }

  .mode-toggle input[type="checkbox"] {
    accent-color: #50fa7b;       
    transform: scale(1.1);       
  }

</style>

<div class="container">
  <div class="editor-wrapper" id="editorWrapper">
    <div id="editor">&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;My Page&lt;/title&gt;
      &lt;script&gt;
        function test() {
          console.log(&quot;Hello&quot;);
        }
      &lt;/script&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;h1&gt;Hello World!&lt;/h1&gt;
  &lt;/body&gt;
&lt;/html&gt;</div>
    <div class="buttons">
      <div>
        <button onclick="updatePreview()">Update Preview</button>
        <button onclick="popOutCode()">Pop Out Code</button>
        <button onclick="exportHTML()">Export HTML</button>
        <button onclick="document.getElementById('fileInput').click()">Import HTML</button>
        <button onclick="toggleFindReplace()">Find/Replace</button>
        <button onclick="toggleConsole()">Toggle Console</button>
        <button onclick="clearConsole()">Clear Console</button>
        <span id="saveStatus" class="save-status"></span>
      </div>
      <div class="mode-toggle">
        <label for="darkModeToggle">Dark Mode</label>
        <input type="checkbox" id="darkModeToggle" onchange="toggleDarkMode()">
        <label for="autocompleteToggle">Autocomplete</label>
        <input type="checkbox" id="autocompleteToggle" onchange="toggleAutocomplete()">
      </div>
    </div>
    <div id="findReplaceModal">
      <div class="draggable-handle">⠶ Find & Replace</div>
      <button class="close-btn" onclick="toggleFindReplace()">×</button>
      <input type="text" id="findText" placeholder="Find">
      <input type="text" id="replaceText" placeholder="Replace with">

<div style="margin-top:10px;">
  <label style="font-size:12px;color:var(--editor-text-primary);">
    <input type="checkbox" id="regexToggle"> Use Regular Expressions
  </label>
</div>
<div class="modal-buttons">
        <button onclick="executeFind()">Find</button>
        <button onclick="executeFindReplace(true)">Replace All</button>
        <button onclick="executeFindReplace(false)">Replace</button>
      </div>
    </div>

  </div>
  <div class="resizer"></div>
  <div id="rightPanel">
    <div id="preview">
      <div id="previewLoading" class="preview-loading">Loading...</div>
    </div>
    <div class="vertical-resizer" id="verticalResizer"></div>
    <div id="consoleSection">
      <div id="consoleOutput"></div>
    </div>
  </div>
</div>

<input type="file" id="fileInput" accept=".html" style="display: none;">

<script src="https://cdnjs.cloudflare.com/ajax/libs/ace/1.36.2/ace.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/ace/1.36.2/ext-language_tools.min.js"></script>

<script>
  const container = document.querySelector('.container');
  const resizer = document.querySelector('.resizer');
  const editorWrapper = document.getElementById('editorWrapper');
  const preview = document.getElementById('preview');
  const previewLoading = document.getElementById('previewLoading');
  const rightPanel = document.getElementById('rightPanel');
  const darkModeToggle = document.getElementById('darkModeToggle');
  const autocompleteToggle = document.getElementById('autocompleteToggle');
  const saveStatus = document.getElementById('saveStatus');
  const fileInput = document.getElementById('fileInput');
  const findReplaceModal = document.getElementById('findReplaceModal');
  const findTextInput = document.getElementById('findText');
  const replaceTextInput = document.getElementById('replaceText');
  const findReplaceHandle = findReplaceModal.querySelector('.draggable-handle');
  const verticalResizer = document.getElementById('verticalResizer');

  ace.require("ace/ext/language_tools");
  const editor = ace.edit("editor", {
      mode: "ace/mode/html",
      theme: "ace/theme/textmate",
      showPrintMargin: false,
      wrap: true,
      showLineNumbers: true,
      enableBasicAutocompletion: true,
      enableLiveAutocompletion: false, 
      enableSnippets: false,
      tabSize: 2,
      useSoftTabs: true,
      highlightActiveLine: true,
      fontSize: 14,
      autoIndent: false 
  });

  editor.commands.bindKey("Ctrl-F", null);
  editor.commands.bindKey("Ctrl-H", null);

  editor.commands.addCommand({
    name: "openFindModal",
    bindKey: { win: "Ctrl-F", mac: "Command-F" },
    exec: function(editor) {
      toggleFindReplace();
      findTextInput.focus();
    },
    readOnly: true
  });

  editor.commands.addCommand({
    name: "openReplaceModal",
    bindKey: { win: "Ctrl-H", mac: "Command-Option-F" },
    exec: function(editor) {
      toggleFindReplace();
      replaceTextInput.focus();
    },
    readOnly: true
  });

  editor.commands.addCommand({
      name: 'showAutocomplete',
      bindKey: { win: 'Ctrl-Space', mac: 'Ctrl-Space' },
      exec: function(editor) {
          editor.completer.showPopup(editor);
      }
  });

  let autocompleteTimeout;
  editor.on('input', function(e) {
      if (!autocompleteToggle.checked) return;
      const session = editor.getSession();
      const cursor = editor.getCursorPosition();
      const line = session.getLine(cursor.row);
      const prefix = line.slice(0, cursor.column);
      const token = session.getTokenAt(cursor.row, cursor.column);
      const mode = session.getMode().$id.split('/').pop(); 

      if (prefix.endsWith('>')) {
          if (editor.completer && editor.completer.popup) {
              editor.completer.detach();
          }
          return;
      }

      if (token && (token.type.includes('string') || token.type.includes('comment') || !token.value.trim())) {
          return;
      }

      const triggers = {
          html: () => {
              return (prefix.match(/<([a-zA-Z][a-zA-Z0-9]*)\s*$/) || 
                     prefix.match(/<([a-zA-Z][a-zA-Z0-9]*)\s+[a-zA-Z-]+=["']?$/) || 
                     prefix.match(/<$/)) && !prefix.match(/<[^>]*>$/); 
          },
          css: () => {
              return prefix.match(/{[^{}]*$/) || prefix.match(/:[^;]*$/); 
          },
          javascript: () => {
              return prefix.match(/\.$/) || prefix.match(/[a-zA-Z_][a-zA-Z0-9_]*$/); 
          }
      };

      const shouldTrigger = triggers[mode]?.() && (token?.value.trim().length >= 2 || prefix.match(/[<:.]/));
      if (!shouldTrigger) return;

      clearTimeout(autocompleteTimeout);
      autocompleteTimeout = setTimeout(() => {
          editor.completer.showPopup(editor);
      }, 250); 
  });

  let previewTimeout;
  editor.on('change', () => {
      clearTimeout(previewTimeout);
      previewTimeout = setTimeout(() => {
          updatePreview();
          autoSave();
      }, 500); 
  });

  let markers = [];
  editor.on('changeSelection', () => {
      const session = editor.getSession();
      markers.forEach(marker => session.removeMarker(marker));
      markers = [];

      const selection = editor.getSelectedText();
      if (selection) {
          const ranges = [];
          const lines = session.getDocument().getAllLines();
          for (let row = 0; row < lines.length; row++) {
              let col = 0;
              while (col < lines[row].length) {
                  const index = lines[row].indexOf(selection, col);
                  if (index === -1) break;
                  ranges.push({
                      start: { row, column: index },
                      end: { row, column: index + selection.length }
                  });
                  col = index + 1;
              }
          }
          ranges.forEach(range => {
              markers.push(session.addMarker(
                  new ace.Range(range.start.row, range.start.column, range.end.row, range.end.column),
                  'ace_highlight-occurrence',
                  'text'
              ));
          });
      }
  });

  function setupConsoleCapture() {
      const consoleOutput = document.getElementById('consoleOutput');
      const originalConsole = {
          log: console.log,
          warn: console.warn,
          error: console.error
      };

      function createLogElement(message, type) {
          const logElement = document.createElement('div');
          logElement.classList.add('console-log', type);
          try {
              logElement.textContent = typeof message === 'object' ? JSON.stringify(message, null, 2) : String(message);
          } catch (e) {
              logElement.textContent = `Error logging: ${e.message}`;
          }
          return logElement;
      }

      console.log = function(...args) {
          args.forEach(arg => consoleOutput.appendChild(createLogElement(arg, 'log')));
          originalConsole.log(...args);
      };

      console.warn = function(...args) {
          args.forEach(arg => consoleOutput.appendChild(createLogElement(arg, 'warn')));
          originalConsole.warn(...args);
      };

      console.error = function(...args) {
          args.forEach(arg => consoleOutput.appendChild(createLogElement(arg, 'error')));
          originalConsole.error(...args);
      };
  }

  function clearConsole() {
      const consoleOutput = document.getElementById('consoleOutput');
      consoleOutput.innerHTML = '';
  }

  function toggleConsole() {
      const consoleSection = document.getElementById('consoleSection');
      if (consoleSection.style.display === 'none' || consoleSection.style.display === '') {
          consoleSection.style.display = 'block';
          verticalResizer.style.display = 'flex';
          rightPanel.style.gridTemplateRows = `1fr 5px 150px`;
      } else {
          consoleSection.style.display = 'none';
          verticalResizer.style.display = 'none';
          rightPanel.style.gridTemplateRows = `1fr`;
      }
  }

  function updatePreview() {
    const consoleOutput = document.getElementById('consoleOutput');
    consoleOutput.innerHTML = '';
    previewLoading.style.display = 'block';

    const code = editor.getValue();
    const iframe = document.createElement('iframe');
    iframe.style.width = '100%';
    iframe.style.height = '100%';
    iframe.style.border = 'none';
    iframe.sandbox = 'allow-scripts allow-same-origin';
    preview.innerHTML = '';
    preview.appendChild(iframe);

    const wrappedCode = `
      <script>
        const send = (type, args) => parent.postMessage({type, args}, '*');
        ['log','warn','error'].forEach(fn => {
          const orig = console[fn];
          console[fn] = (...a) => { send(fn, a.map(x => String(x))); };
        });
        window.onerror = (msg, src, line, col) => send('error', [msg + ' (' + line + ':' + col + ')']);
      <\/script>
      ${code}
    `;

    const blob = new Blob([wrappedCode], { type: 'text/html' });
    iframe.src = URL.createObjectURL(blob);

    setTimeout(() => { previewLoading.style.display = 'none'; }, 100);
  }

  window.addEventListener('message', (e) => {
    const { type, args } = e.data || {};
    if (!type || !args) return;
    const log = document.createElement('div');
    log.classList.add('console-log', type);
    log.textContent = args.join(' ');
    document.getElementById('consoleOutput').appendChild(log);
  });

  function autoSave() {
      const code = editor.getValue();
      localStorage.setItem('htmlPlaygroundCode', code);
      saveStatus.textContent = 'Saved ' + new Date().toLocaleTimeString(); saveStatus.style.opacity = 1; setTimeout(() => saveStatus.style.opacity = 0, 1000);
      setTimeout(() => saveStatus.textContent = '', 2000);
  }

  function popOutCode() {
      const code = editor.getValue();
      const blob = new Blob([code], { type: 'text/html' });
      const url = URL.createObjectURL(blob);
      window.open(url, '_blank');
      setTimeout(() => URL.revokeObjectURL(url), 1000);
  }

  function exportHTML() {
      const code = editor.getValue();
      const blob = new Blob([code], { type: 'text/html' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'exported.html';
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      setTimeout(() => URL.revokeObjectURL(url), 1000);
  }

  fileInput.addEventListener("change", function(event) {
      const file = event.target.files[0];
      if (!file) return;
      const reader = new FileReader();
      reader.onload = function() {
          editor.setValue(reader.result);
      };
      reader.readAsText(file);
  });

  function toggleFindReplace() {
      findReplaceModal.style.display = 
          findReplaceModal.style.display === 'block' ? 'none' : 'block';
      findTextInput.value = '';
      replaceTextInput.value = '';
      if (findReplaceModal.style.display === 'none') {
          const session = editor.getSession();
          markers.forEach(marker => session.removeMarker(marker));
          markers = [];
      }
  }

  let isDraggingModal = false;
  let modalOffsetX, modalOffsetY;

  findReplaceHandle.addEventListener('mousedown', (e) => {
      isDraggingModal = true;
      modalOffsetX = e.clientX - findReplaceModal.offsetLeft;
      modalOffsetY = e.clientY - findReplaceModal.offsetTop;
      e.preventDefault();
  });

  document.addEventListener('mousemove', (e) => {
      if (!isDraggingModal) return;
      let newX = e.clientX - modalOffsetX;
      let newY = e.clientY - modalOffsetY;
      const editorRect = editorWrapper.getBoundingClientRect();
      newX = Math.max(0, Math.min(newX, editorRect.width - findReplaceModal.offsetWidth));
      newY = Math.max(0, Math.min(newY, editorRect.height - findReplaceModal.offsetHeight));
      findReplaceModal.style.left = `${newX}px`;
      findReplaceModal.style.top = `${newY}px`;
      findReplaceModal.style.right = 'auto';
      findReplaceModal.style.bottom = 'auto';
  });

  document.addEventListener('mouseup', () => {
      isDraggingModal = false;
  });

  function executeFind() {
    const session = editor.getSession();
    markers.forEach(marker => session.removeMarker(marker));
    markers = [];

    const findText = findTextInput.value;
    const useRegex = document.getElementById('regexToggle').checked;
    if (!findText) return;

    const lines = session.getDocument().getAllLines();
    const ranges = [];

    let regexObj = null;
    if (useRegex) {
      try {
        regexObj = new RegExp(findText, 'g');
      } catch (e) {
        alert('Invalid regex: ' + e.message);
        return;
      }
    }

    for (let row = 0; row < lines.length; row++) {
      const line = lines[row];
      if (useRegex) {
        let match;
        while ((match = regexObj.exec(line)) !== null) {

          if (match[0].length === 0) {
            regexObj.lastIndex++;
            continue;
          }
          ranges.push({
            start: { row, column: match.index },
            end: { row, column: match.index + match[0].length }
          });
        }

        regexObj.lastIndex = 0;
      } else {
        let col = 0;
        while (col < line.length) {
          const index = line.indexOf(findText, col);
          if (index === -1) break;
          ranges.push({
            start: { row, column: index },
            end: { row, column: index + findText.length }
          });
          col = index + 1;
        }
      }
    }

    ranges.forEach(range => {
      markers.push(session.addMarker(
        new ace.Range(range.start.row, range.start.column, range.end.row, range.end.column),
        'ace_highlight-occurrence',
        'text'
      ));
    });
  }

  function executeFindReplace(replaceAll) {
      const findText = findTextInput.value;
  const useRegex = document.getElementById('regexToggle').checked;
  const flags = 'g';
  let regexObj = null;
  if (useRegex) {
      try { regexObj = new RegExp(findText, flags); }
      catch(e) { alert('Invalid regex: ' + e.message); return; }
  }

      const replaceText = replaceTextInput.value;
      if (!findText) return;

      const session = editor.getSession();
      let count = 0;

      if (replaceAll) {
          const lines = session.getDocument().getAllLines();
          for (let row = 0; row < lines.length; row++) {
              let line = lines[row];
              let col = 0;
              while (col < line.length) {
                  const index = useRegex ? line.slice(col).search(regexObj) + col : line.indexOf(findText, col);
                  if (index === -1) break;
                  session.replace(
                      new ace.Range(row, index, row, index + findText.length),
                      replaceText
                  );
                  line = session.getLine(row); 
                  col = index + replaceText.length;
                  count++;
              }
          }
          saveStatus.textContent = `Replaced ${count} occurrence(s)`;
      } else {
          const cursor = editor.getCursorPosition();
          const line = session.getLine(cursor.row);
          const index = useRegex ? line.slice(cursor.column).search(regexObj) + cursor.column : line.indexOf(findText, cursor.column);
          if (index !== -1) {
              if (confirm("Replace this occurrence?")) {
                  session.replace(
                      new ace.Range(cursor.row, index, cursor.row, index + findText.length),
                      replaceText
                  );
                  saveStatus.textContent = "Replaced 1 occurrence";
                  count++;
              }
          } else {
              alert("Text not found");
          }
      }

      updatePreview();
      autoSave();
      setTimeout(() => saveStatus.textContent = "", 2000);
      executeFind();
  }

  function toggleAutocomplete() {
      const isEnabled = autocompleteToggle.checked;
      localStorage.setItem('htmlPlaygroundAutocomplete', isEnabled);
      editor.setOption('enableLiveAutocompletion', isEnabled);
  }

  function toggleDarkMode() {
      editorWrapper.classList.toggle('dark-mode');
      const isDarkMode = editorWrapper.classList.contains('dark-mode');
      editor.setTheme(isDarkMode ? "ace/theme/monokai" : "ace/theme/textmate");
      localStorage.setItem('htmlPlaygroundDarkMode', isDarkMode);
  }

  function loadSavedPreferences() {
      const savedCode = localStorage.getItem('htmlPlaygroundCode');
      if (savedCode) {
          editor.setValue(savedCode);
          updatePreview();
      }
      const savedDarkMode = true;
      if (savedDarkMode) {
          darkModeToggle.checked = true;
          editorWrapper.classList.add('dark-mode');
          editor.setTheme("ace/theme/monokai");
      }
      const savedAutocomplete = "true";
      const isAutocompleteEnabled = savedAutocomplete !== null ? savedAutocomplete === 'true' : true;
      autocompleteToggle.checked = isAutocompleteEnabled;
      editor.setOption('enableLiveAutocompletion', isAutocompleteEnabled);
  }

  function loadRegexPreference() {
    const savedRegex = localStorage.getItem('htmlPlaygroundRegex');
    const regexToggle = document.getElementById('regexToggle');

    if (savedRegex === null) {

      regexToggle.checked = true;
      localStorage.setItem('htmlPlaygroundRegex', 'true');
    } else {

      regexToggle.checked = (savedRegex === 'true');
    }

    regexToggle.addEventListener('change', () => {
      localStorage.setItem('htmlPlaygroundRegex', regexToggle.checked);
    });
  }

  let isDragging = false;
  resizer.addEventListener("pointerdown", (e) => {
      isDragging = true;
      document.body.style.cursor = 'col-resize';
      rightPanel.style.pointerEvents = 'none';
      document.addEventListener("pointermove", resizePanels);
      document.addEventListener("pointerup", () => {
          isDragging = false;
          document.body.style.cursor = 'default';
          rightPanel.style.pointerEvents = 'auto';
          document.removeEventListener("pointermove", resizePanels);
      });
  });

  function resizePanels(e) {
      if (!isDragging) return;
      const containerRect = container.getBoundingClientRect();
      const containerWidth = containerRect.width;
      const mouseXRelative = e.clientX - containerRect.left;
      const minWidth = 100;
      const newLeftWidth = Math.max(minWidth, Math.min(mouseXRelative, containerWidth - minWidth - 5));
      container.style.gridTemplateColumns = `${newLeftWidth}px 5px ${containerWidth - newLeftWidth - 5}px`;
      editor.renderer.updateFull();
  }

  let isDraggingVertical = false;
  verticalResizer.addEventListener("pointerdown", (e) => {
      isDraggingVertical = true;
      verticalResizer.setPointerCapture(e.pointerId);
      document.body.style.cursor = 'row-resize';
      document.addEventListener("pointermove", resizeVerticalPanels);
      document.addEventListener("pointerup", () => {
          isDraggingVertical = false;
          document.body.style.cursor = 'default';
          verticalResizer.releasePointerCapture(e.pointerId);
          document.removeEventListener("pointermove", resizeVerticalPanels);
      });
  });

  function resizeVerticalPanels(e) {
      if (!isDraggingVertical) return;
      const panelRect = rightPanel.getBoundingClientRect();
      const offsetY = e.clientY - panelRect.top;
      const minHeight = 50;
      const maxHeight = panelRect.height - minHeight - 5;
      const newPreviewHeight = Math.max(minHeight, Math.min(offsetY, maxHeight));
      const consoleHeight = panelRect.height - newPreviewHeight - 5;
      rightPanel.style.gridTemplateRows = `${newPreviewHeight}px 5px ${consoleHeight}px`;
  }

  setupConsoleCapture();

  const storedCols = localStorage.getItem('htmlPlaygroundCols');
  if (storedCols) container.style.gridTemplateColumns = storedCols;

  new ResizeObserver(() => {
      localStorage.setItem('htmlPlaygroundCols', container.style.gridTemplateColumns);
  }).observe(container);

  loadSavedPreferences();
  loadRegexPreference();

  darkModeToggle.checked = true;
  editorWrapper.classList.add("dark-mode");
  editor.setTheme("ace/theme/monokai");
  autocompleteToggle.checked = true;
  editor.setOption("enableLiveAutocompletion", true);
  updatePreview();
</script>
</html>
